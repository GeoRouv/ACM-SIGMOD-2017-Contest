Το αρχείο [tar] περιέχει τα εξής αρχεία:

1) Directory "src":

Αρχεία:

i) makefile

ii) main.c
Ανοίγει τα αρχεία που δόθηκαν στη γραμμή εντολών
Δημιουργεί ένα Trie instance και βάζει μέσα του τα n-grams που βρίσκονται στο init_file.
Μετά, εκτελεί τις εντολές που βρίσκονται στο query_file, αγνοώντας προς το παρόν την εντολή F.

iii) Trie.c - Trie.h

Χρησιμοποιούμε ολική απόκρυψη, ο χρήστης έχει πρόσβαση μόνο σε δείκτη σε αρχικό κόμβο και εκτελεί πράξεις μόνο μέσω των συναρτήσεων.
Κατά τη δημιουργία του δέντρου φτιάχνεται ένας αρχικός κόμβος που δεν περιέχει λέξη.
Η δομή TrieNode έχει τα εξής πεδία: word, children, arraySize, numChildren, isFinal

word είναι η λέξη που αποθηκεύεται σε κάθε κόμβο

children είναι ο πίνακας με τα παιδιά του κόμβου για τον οποίο δεσμεύεται κάποιος αρχικός χώρος άσχετα με τα αρχικά παιδιά, αν χρειαστεί διπλασιάζεται και είναι
ταξινομημένος πάντα σε αλφαβητική σειρά ως προς το word
Το children έχει by value τα παιδιά και όχι δείκτες σε αυτά για εκμετάλευση των πλεονεκτημάτων του locality. Δοκιμάστηκε έκδοση και με δείκτες η οποία έτρεξε στο
δεύτερο dataset που ανέβηκε με σημαντική διαφορά, περίπου -10 δευτερόλέπτα σε επεξεργαστές i5(2.67ghz) και amd phenom(3.4ghz)

arraySize το μέγεθος όσο αφορά τη μνήμη του παραπάνω πίνακα.

numChildren πόσα κελιά έχουν όντως μέσα πληροφορία.

isFinal υποδεικνύει αν η λέξη είναι τερματική ή οχι. Είναι τύπου Bool που ορίζεται στο header αρχείο. Το ορίσαμε ως char για να καταναλώνουμε 1 byte και όχι 4 λόγω int.

TrieAdd:
	Ψάχνει με binary search αν υπάρχει ως παιδί το επόμενο token από το string που δόθηκε. Λόγω strtok δεν μπορεί να δοθεί const char*.
	Αν δεν υπάρχει, το δημιουργεί και το βάζει στη σωστή θέση (αυτή που έχει επιστραφεί από το first του binary search) ώστε να μένει ταξινομημένος ο πίνακας.
	Συνεχίζει μέχρι να εξαντληθεί το string που δόθηκε για εισαγωγή και επιστρέφει Bool σύμφωνα με το αν τα κατάφερε.
	Χρησιμοποιείται η συνάρτηση memmove για το γρήγορο shift των στοιχείων του πίνακα μετά την εισαγωγή νέου κόμβου.
	Δοκιμάστηκε και με συναρτήσεις και αναθέσεις με = , το οποίο ήταν ελαφρώς πιο αργό. Υπάρχουν ακόμα ως comment μέσα στο πηγαίο κώδικα.

break_string:
	Σπάει ένα string στις λέξεις του και τις βάζει σε δισδιάστατο πίνακα, μία λέξη ανά γραμμή.
	
TrieQuestion:
	Για κάθε συνδυασμό, αν υπάρχει το ngram από i έως curr_word_index, το προσθέτει στην ουρά.
	Στο τέλος επιστρέφει μία λίστα με τα αποτελέσματα, χωρίς duplicates.
	Χρησιμοποιείται binary search για την αναζήτηση σε κάθε επίπεδο του trie. Δοκιμάστηκε και έκδοση με
	γραμμική αναζήτηση, και η διαφορά στους χρόνους με input το small dataset ήταν της τάξης των 40-45 
	δευτερολέπτων (η έκδοση με το binary search τρέχει γρηγορότερα).
	
TrieDestroy:
	Καταστρέφει τη δομή αναδρομικά, χρησιμοποιώντας την TrieDestroyPrivate γιατί ο χρήστης δεν έχει πρόσβαση στον δείκτη root.
	Κάθε αναδρομή-κόμβος, καταστρέφει τον εαυτό της αφού καλέσει την ίδια συνάρτηση για όλα τα παιδιά.

TrieDelete:
	Κατεβαίνει αναδρομικά το δέντρο μέχρι να μην μπορεί να πάρει άλλο token από το string εισόδου και βρίσκει και μονοπάτι με τα token  που παίρνει κάθε φορα.
	Στο τέλος, φτάνει έναν κόμβο πριν τον τελικό και αν όντως υπάρχει το ngram στη δομή μας, τον καταστρέφει ή του βγάζει το final, καταστρέφει τον εαυτό του και γυρνάει πίσω αναδρομικά
	μέχρι να βρει διακλάδωση ή άλλο final αν δεν έβγαλε απλά το final από τον τελικό. Κάθε κλήση επιστρέφει στην προηγούμενη, αν πρέπει να διαγραφεί ο κόμβος της ή όχι.
	Επειδή ο χρήστης δεν έχει πρόσβαση στο δείκτη root, καλείτα η TrieDeletePrivate.
	
GetFirstToken:
	Παίρνει ένα string, γυρνάει επόμενο token και μέσω δείκτη επιστρέφει αν υπάρχει άλλο token παραπέρα στο string και τη θέση του.
	
iv) Queue.c - Queue.h
	Είναι μια βοηθητική δομή που χρησιμοποιούμε για να σώζουμε τα αποτελέσματα της TrieQuestion.
	Είναι λίστα γενικού σκοπού και μπορεί να έχει σε κάθε κόμβο οποιονδήποτε τύπο, στην περίπτωσή μας σώζει διευθύνσεις string.
	Έχει μία συνάρτηση, ειδική ώστε όταν γίνεται μία πρόσθεση στοιχείου να ελέγχει αν το string υπάρχει ήδη μέσα και να μην το βάζει.


2) Directory "UnitTest:

	Για unit testing χρησιμοποιούμε το Framework του unity.
	Έχουμε μία main μέσα σε ένα αντίγραφο του Trie.c όπου κάνουμε διάφορα τεστ για διάφορες περιπτώσεις, τα οποία κάνουν όλα pass.

i) Directory Unity-master
	Περιέχει ό,τι χρειάζεται για να χρησιμοποιήσουμε το unity.

ii) makefile

iii) mainTEST_TRIE.c
	Εδώ μέσα γίνονται τα τεστ που αναφέραμε παραπάνω.
